import re # regular expressions used for parsing the tags file
import os # to get the current working directory
import os.path

__author__ = "ccheever" # Charlie Cheever <charlie@facebook.com>, <ccheever@gmail.com>
__date__ = "Wed Jul 19 03:20:41 PDT 2006"

__doc__ = """
    This is a module for working with the 'tags' files generated by ctags.
    It works best with exuberant ctags but has been patched up to work 
    OK with other version of ctags.
"""


__contextRegularExpression = re.compile(r".*\t\/\^(.*)\$\/;\"\t.*")
__contextRegularExpression = re.compile(r".*\t\/\^(.*)\$\/.*")

class CantFindTagsFile(Exception):
    pass

class Ctags:
    def __init__(self, tagsFilePath=None):
        if not tagsFilePath:
            tagsFilePath = findTagsFile()
        self.tagsFile = tagsFilePath
        self.tagsRoot = os.path.dirname(tagsFilePath)
        self.pyTags = parseTagsFile(tagsFilePath)

class CtagsFunctionSignatures:
    def __init__(self, tagsFilePath=None):
        if not tagsFilePath:
            tagsFilePath = findTagsFile()
        self.tagsFile = tagsFilePath
        self.tagsRoot = os.path.dirname(tagsFilePath)
        self.functionSignatures = parseFunctionSignatures(tagsFilePath)

def findTagsFile(dir=None, tagsFileName="tags"):
    "looks for a file in the current or given directory and all parent directories of that directory up until the root"
    fileInDir = lambda d: d + os.path.sep + tagsFileName
    if not dir:
        dir = os.getcwd()
    while not os.path.isfile(fileInDir(dir)):
        dir = os.path.normpath(dir)
        if dir == os.path.sep:
            raise CantFindTagsFile
        dir += os.path.sep + os.path.pardir

    return fileInDir(os.path.normpath(dir))
        
def parseTagsFile(tagsFilePath):
    "parses a tags file generated by ctags, returns a dict of identifiers with info about them"
    tagsFile = open(tagsFilePath)
    pyTags = {}
    for line in tagsFile:
        if line[:6] == '!_TAG_': # tag program metadata
            continue
        cols = line.rstrip().split("\t")
        identifier = cols[0]
        filePath = cols[1]
        type = cols[-1] # type is the last field

        # if the last field is more than one char, 
        # then there probably just isn't a type
        if len(type) > 1:
            type = None
            
        try:
            (context, ) = __contextRegularExpression.match(line).groups()
        except ValueError:
            continue
        except AttributeError:
            continue
        
        if not pyTags.has_key(identifier):
            pyTags[identifier] = []
        pyTags[identifier].append({"file": filePath, "context": context, "type": type})

    return pyTags
        
__functionArgsRegularExpression = re.compile(r".*function\s+([^\);]*[\)]*)")
def parseFunctionSignatures(tagsFilePath):
    tagsFile = open(tagsFilePath)
    functionsToSignatures = {}
    for line in tagsFile:
        if line[:6] == '!_TAG_':
            continue
        try:
            context  = __contextRegularExpression.match(line).groups()[0]
            signature = __functionArgsRegularExpression.match(context).groups()[0]
        except ValueError:
            continue
        except AttributeError:
            continue
        except IndexError:
            continue

        cols = line.rstrip().split("\t")
        identifier = cols[0]
        try:
            functionsToSignatures[identifier].append(signature)
        except KeyError:
            functionsToSignatures[identifier] = [signature]

    return functionsToSignatures

        


